generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String               @id @default(uuid())
  email              String               @unique
  password           String?
  firstName          String
  lastName           String
  phone              String?
  userType           String               @default("Client")
  managerId          String?
  isActive           Boolean              @default(true)
  lastLoginAt        DateTime?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  azureId            String?              @unique
  userPrincipalName  String?              @unique
  jobTitle           String?
  officeLocation     String?
  mobilePhone        String?
  avatar             String?
  lastSyncAt         DateTime?
  classifierFeedback ClassifierFeedback[]
  createdKBArticles  KnowledgeBase[]      @relation("KBCreator")
  comments           TicketComment[]
  assignedTickets    Ticket[]             @relation("TicketAssignee")
  createdTickets     Ticket[]             @relation("TicketRequester")
  departments        UserDepartment[]
  alternateEmails    UserEmail[]
  preferences        UserPreference?
  roles              UserRole[]
  moduleAccess       UserModuleAccess[]
  attachments        Attachment[]         @relation("AttachmentUploader")
  manager            User?                @relation("UserManager", fields: [managerId], references: [id])
  directReports      User[]               @relation("UserManager")

  @@map("users")
}

model UserEmail {
  id         String    @id @default(uuid())
  userId     String    @map("user_id")
  email      String    @unique
  emailType  String    @default("alternate") @map("email_type")
  isPrimary  Boolean   @default(false) @map("is_primary")
  isVerified Boolean   @default(false) @map("is_verified")
  addedAt    DateTime  @default(now()) @map("added_at")
  addedBy    String?   @map("added_by")
  verifiedAt DateTime? @map("verified_at")
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([email])
  @@map("user_emails")
}

model Role {
  id           String             @id @default(uuid())
  name         String             @unique
  description  String?
  permissions  Json
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  users        UserRole[]
  moduleAccess RoleModuleAccess[]

  @@map("roles")
}

model UserRole {
  id     String @id @default(uuid())
  userId String
  roleId String
  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@map("user_roles")
}

model Ticket {
  id                   String           @id @default(uuid())
  ticketNumber         String           @unique
  title                String
  description          String
  status               TicketStatus     @default(NEW)
  priority             TicketPriority   @default(NORMAL)
  category             String?
  requesterId          String?
  assigneeId           String?
  departmentId         String?
  emailConversationId  String?
  parentTicketId       String?
  aiDraftResponse      String?
  aiDraftGeneratedAt   DateTime?
  aiDraftGeneratedBy   String?
  satisfactionRating   Int?
  satisfactionFeedback String?
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  resolvedAt           DateTime?
  closedAt             DateTime?
  aiDecision           AIDecision?
  attachments          Attachment[]
  inboundMessages      InboundMessage[]
  messageAssets        MessageAsset[]   @relation("TicketAssets")
  comments             TicketComment[]
  kbUsage              TicketKBUsage[]
  ticketMessages       TicketMessage[]
  assignee             User?            @relation("TicketAssignee", fields: [assigneeId], references: [id])
  parentTicket         Ticket?          @relation("TicketThread", fields: [parentTicketId], references: [id])
  childTickets         Ticket[]         @relation("TicketThread")
  requester            User?            @relation("TicketRequester", fields: [requesterId], references: [id])

  @@index([parentTicketId])
  @@map("tickets")
}

model TicketComment {
  id        String   @id @default(uuid())
  ticketId  String
  userId    String
  content   String
  isPublic  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id])

  @@map("ticket_comments")
}

model WeeklyTicketStats {
  id                String   @id @default(uuid())
  weekStartDate     DateTime
  weekEndDate       DateTime
  year              Int
  weekNumber        Int
  totalTickets      Int      @default(0)
  newTickets        Int      @default(0)
  openTickets       Int      @default(0)
  pendingTickets    Int      @default(0)
  onHoldTickets     Int      @default(0)
  solvedTickets     Int      @default(0)
  closedTickets     Int      @default(0)
  unassignedTickets Int      @default(0)
  effectiveness     Float    @default(0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([year, weekNumber])
  @@map("weekly_ticket_stats")
}

model UserPreference {
  id                 String   @id @default(uuid())
  userId             String   @unique
  personalViewOrder  String?
  companyViewOrder   String?
  dashboardCardOrder String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_preferences")
}

model Department {
  id            String              @id @default(uuid())
  name          String              @unique
  description   String?
  color         String              @default("gray")
  isActive      Boolean             @default(true)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  keywords      DepartmentKeyword[]
  knowledgeBase KnowledgeBase[]
  users         UserDepartment[]

  @@map("departments")
}

model UserDepartment {
  id           String     @id @default(uuid())
  userId       String
  departmentId String
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, departmentId])
  @@map("user_departments")
}

model DepartmentKeyword {
  id           String     @id @default(uuid())
  departmentId String
  keyword      String
  weight       Float      @default(1.0)
  isActive     Boolean    @default(true)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  @@unique([departmentId, keyword])
  @@map("department_keywords")
}

model KnowledgeBase {
  id              String          @id @default(uuid())
  title           String
  content         String
  tags            String?
  departmentId    String?
  createdById     String?
  isActive        Boolean         @default(true)
  embedding       String?
  images          String?
  usageCount      Int             @default(0)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  createdBy       User?           @relation("KBCreator", fields: [createdById], references: [id])
  department      Department?     @relation(fields: [departmentId], references: [id])
  ticketResponses TicketKBUsage[]

  @@map("knowledge_base")
}

model TicketKBUsage {
  id             String        @id @default(uuid())
  ticketId       String
  kbId           String
  relevance      Float         @default(0.0)
  usedInResponse Boolean       @default(false)
  createdAt      DateTime      @default(now())
  knowledgeBase  KnowledgeBase @relation(fields: [kbId], references: [id], onDelete: Cascade)
  ticket         Ticket        @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@unique([ticketId, kbId])
  @@map("ticket_kb_usage")
}

model AIDecision {
  id                   String   @id @default(uuid())
  ticketId             String   @unique
  suggestedDepartment  String?
  departmentConfidence Float?   @default(0.0)
  keywordMatches       String?
  aiReasoning          String?
  finalDepartment      String?
  wasOverridden        Boolean  @default(false)
  createdAt            DateTime @default(now())
  ticket               Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("ai_decisions")
}

model AuditLog {
  id               String   @id @default(uuid())
  ts               DateTime @default(now())
  action           String
  actorId          String?  @map("actor_id")
  actorEmail       String   @map("actor_email")
  actorType        String   @map("actor_type")
  impersonatedUser String?  @map("impersonated_user")
  entityType       String   @map("entity_type")
  entityId         String   @map("entity_id")
  targetId         String?  @map("target_id")
  requestId        String?  @map("request_id")
  correlationId    String?  @map("correlation_id")
  ip               String?
  userAgent        String?  @map("user_agent")
  prevValues       String?  @map("prev_values")
  newValues        String?  @map("new_values")
  metadata         String?
  redactionLevel   Int      @default(0) @map("redaction_level")
  prevHash         String?  @map("prev_hash")
  hash             String

  @@unique([action, entityId, requestId])
  @@index([ts(sort: Desc)])
  @@index([entityType, entityId, ts(sort: Desc)])
  @@index([action, ts(sort: Desc)])
  @@index([actorEmail, ts(sort: Desc)])
  @@index([requestId])
  @@index([correlationId])
  @@map("audit_log")
}

model AuditLogDLQ {
  id          String    @id @default(uuid())
  failedAt    DateTime  @default(now()) @map("failed_at")
  error       String
  retryCount  Int       @default(0) @map("retry_count")
  lastRetryAt DateTime? @map("last_retry_at")
  eventData   String    @map("event_data")
  resolved    Boolean   @default(false)
  resolvedAt  DateTime? @map("resolved_at")

  @@index([failedAt(sort: Desc)])
  @@index([resolved, failedAt(sort: Desc)])
  @@map("audit_log_dlq")
}

model AuditChainVerification {
  id              String    @id @default(uuid())
  verifiedAt      DateTime  @default(now()) @map("verified_at")
  rangeStart      DateTime  @map("range_start")
  rangeEnd        DateTime  @map("range_end")
  totalEntries    Int       @map("total_entries")
  verifiedEntries Int       @map("verified_entries")
  firstFailureId  String?   @map("first_failure_id")
  firstFailureTs  DateTime? @map("first_failure_ts")
  status          String
  details         String?

  @@index([verifiedAt(sort: Desc)])
  @@index([status, verifiedAt(sort: Desc)])
  @@map("audit_chain_verification")
}

model Attachment {
  id          String   @id @default(uuid())
  ticketId    String
  userId      String
  fileName    String
  fileSize    Int
  mimeType    String
  filePath    String
  uploadedAt  DateTime @default(now())
  expiresAt   DateTime
  sentInEmail Boolean  @default(false) // Track if attachment was already sent in an email
  ticket      Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user        User     @relation("AttachmentUploader", fields: [userId], references: [id])

  @@index([userId])
  @@index([ticketId])
  @@index([expiresAt])
  @@map("attachments")
}

model AttachmentDeletionLog {
  id        String   @id @default(uuid())
  userId    String
  fileName  String
  fileSize  Int
  filePath  String
  deletedAt DateTime @default(now())
  deletedBy String?
  reason    String

  @@index([userId])
  @@index([deletedAt])
  @@map("attachment_deletion_logs")
}

model ClassifierFeedback {
  id               String   @id @default(uuid())
  ticketId         String
  emailFrom        String?
  emailSubject     String?
  emailBody        String?
  originalCategory String?
  feedbackType     String
  correctCategory  String?
  reason           String?
  userId           String
  createdAt        DateTime @default(now())
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@index([feedbackType])
  @@index([createdAt])
  @@map("classifier_feedback")
}

model EmailIngest {
  id              String            @id @default(uuid())
  messageId       String            @unique @map("message_id")
  inReplyTo       String?           @map("in_reply_to")
  references      String?
  conversationId  String?           @map("conversation_id")
  threadId        String?           @map("thread_id")
  from            String
  to              String
  cc              String?
  bcc             String?
  subject         String
  html            String?
  text            String?
  snippet         String?
  rawHeaders      String?           @map("raw_headers")
  parsedJson      String?           @map("parsed_json")
  dedupeHash      String            @map("dedupe_hash")
  receivedAt      DateTime          @default(now()) @map("received_at")
  processedAt     DateTime?         @map("processed_at")
  processingError String?           @map("processing_error")
  ticketId        String?           @map("ticket_id")
  attachments     EmailAttachment[]

  @@index([messageId])
  @@index([inReplyTo])
  @@index([conversationId])
  @@index([receivedAt(sort: Desc)])
  @@index([dedupeHash])
  @@index([from, receivedAt(sort: Desc)])
  @@map("email_ingest")
}

model EmailAttachment {
  id              String      @id @default(uuid())
  emailIngestId   String      @map("email_ingest_id")
  filename        String
  contentType     String      @map("content_type")
  size            Int
  storageKey      String?     @map("storage_key")
  storageUrl      String?     @map("storage_url")
  isInline        Boolean     @default(false) @map("is_inline")
  cid             String?
  uploadedAt      DateTime    @default(now()) @map("uploaded_at")
  virusScanStatus String?     @map("virus_scan_status")
  virusScanAt     DateTime?   @map("virus_scan_at")
  emailIngest     EmailIngest @relation(fields: [emailIngestId], references: [id], onDelete: Cascade)

  @@index([emailIngestId])
  @@index([cid])
  @@index([storageKey])
  @@map("email_attachments")
}

model TicketMessage {
  id          String    @id @default(uuid())
  ticketId    String    @map("ticket_id")
  kind        String
  authorId    String?   @map("author_id")
  authorEmail String?   @map("author_email")
  authorName  String?   @map("author_name")
  html        String?
  text        String?
  subject     String?
  metadata    String?
  isPublic    Boolean   @default(true) @map("is_public")
  createdAt   DateTime  @default(now()) @map("created_at")
  editedAt    DateTime? @map("edited_at")
  ticket      Ticket    @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId, createdAt])
  @@index([authorEmail])
  @@map("ticket_messages")
}

model DepartmentSequence {
  id             String   @id @default(uuid())
  departmentCode String   @unique @map("department_code")
  departmentName String   @map("department_name")
  nextNumber     Int      @default(1) @map("next_number")
  lastReservedAt DateTime @default(now()) @map("last_reserved_at")

  @@map("department_sequences")
}

model Tag {
  id          String      @id @default(uuid())
  name        String      @unique
  displayName String      @map("display_name")
  color       String?
  category    String?
  isActive    Boolean     @default(true) @map("is_active")
  usageCount  Int         @default(0) @map("usage_count")
  createdAt   DateTime    @default(now()) @map("created_at")
  tickets     TicketTag[]

  @@index([name])
  @@index([category])
  @@map("tags")
}

model TicketTag {
  id       String   @id @default(uuid())
  ticketId String   @map("ticket_id")
  tagId    String   @map("tag_id")
  addedAt  DateTime @default(now()) @map("added_at")
  addedBy  String?  @map("added_by")
  tag      Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([ticketId, tagId])
  @@index([ticketId])
  @@index([tagId])
  @@map("ticket_tags")
}

model RateLimitEntry {
  id         String   @id @default(uuid())
  identifier String
  endpoint   String
  requestAt  DateTime @default(now()) @map("request_at")
  expiresAt  DateTime @map("expires_at")

  @@index([identifier, endpoint, requestAt(sort: Desc)])
  @@index([expiresAt])
  @@map("rate_limit_entries")
}

model EmailDLQ {
  id             String    @id @default(uuid())
  failedAt       DateTime  @default(now()) @map("failed_at")
  error          String
  stackTrace     String?   @map("stack_trace")
  retryCount     Int       @default(0) @map("retry_count")
  lastRetryAt    DateTime? @map("last_retry_at")
  messageId      String?   @map("message_id")
  from           String?
  subject        String?
  rawPayload     String    @map("raw_payload")
  resolved       Boolean   @default(false)
  resolvedAt     DateTime? @map("resolved_at")
  resolvedBy     String?   @map("resolved_by")
  resolutionNote String?   @map("resolution_note")

  @@index([failedAt(sort: Desc)])
  @@index([resolved, failedAt(sort: Desc)])
  @@index([messageId])
  @@map("email_dlq")
}

model InboundMessage {
  id            String         @id @default(uuid())
  ticketId      String         @map("ticket_id")
  messageId     String         @unique @map("message_id")
  from          String
  subject       String
  receivedAt    DateTime       @default(now()) @map("received_at")
  htmlRaw       String?        @map("html_raw")
  htmlSanitized String?        @map("html_sanitized")
  textPlain     String?        @map("text_plain")
  createdAt     DateTime       @default(now()) @map("created_at")
  ticket        Ticket         @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  assets        MessageAsset[]

  @@index([ticketId])
  @@index([messageId])
  @@index([receivedAt(sort: Desc)])
  @@map("inbound_messages")
}

model MessageAsset {
  id         String         @id @default(uuid())
  messageId  String         @map("message_id")
  ticketId   String         @map("ticket_id")
  kind       AssetKind
  contentId  String?        @map("content_id")
  filename   String
  mime       String
  size       Int
  sha256     String
  width      Int?
  height     Int?
  storageKey String         @map("storage_key")
  variant    AssetVariant
  createdAt  DateTime       @default(now()) @map("created_at")
  message    InboundMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  ticket     Ticket         @relation("TicketAssets", fields: [ticketId], references: [id], onDelete: Cascade)

  @@unique([messageId, contentId, variant])
  @@index([messageId])
  @@index([ticketId])
  @@index([sha256])
  @@index([contentId])
  @@map("message_assets")
}

model BlockedEmailDomain {
  id        String   @id @default(uuid())
  domain    String   @unique
  reason    String?
  blockedBy String
  blockedAt DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([domain])
  @@map("blocked_email_domains")
}

// System modules (features/sections of the application)
model Module {
  id          String   @id @default(uuid())
  name        String   @unique                     // Human-readable name (e.g., "Tickets", "Reports")
  key         String   @unique                     // Unique key (e.g., "tickets", "reports")
  description String?                              // Description of the module
  icon        String?                              // Icon name for UI (e.g., "Ticket", "BarChart3")
  route       String?                              // Primary route path (e.g., "/tickets", "/reports")
  category    String?                              // Module category (e.g., "core", "admin", "features")
  isCore      Boolean  @default(false)            // Core modules can't be disabled (Dashboard, Profile)
  isActive    Boolean  @default(true)             // Module is active and available
  sortOrder   Int      @default(0)                // Display order in UI
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  userModuleAccess UserModuleAccess[]
  roleModuleAccess RoleModuleAccess[]

  @@index([key])
  @@index([isActive])
  @@map("modules")
}

// Per-user module access (overrides role-based access)
model UserModuleAccess {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  moduleId  String   @map("module_id")
  hasAccess Boolean  @default(true)              // Grant or deny access
  grantedBy String?  @map("granted_by")          // Admin who granted/revoked access
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  module Module @relation(fields: [moduleId], references: [id], onDelete: Cascade)

  @@unique([userId, moduleId])
  @@index([userId])
  @@index([moduleId])
  @@map("user_module_access")
}

// Per-role module access (default access for users with this role)
model RoleModuleAccess {
  id        String   @id @default(uuid())
  roleId    String   @map("role_id")
  moduleId  String   @map("module_id")
  hasAccess Boolean  @default(true)              // Grant or deny access
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)
  module Module @relation(fields: [moduleId], references: [id], onDelete: Cascade)

  @@unique([roleId, moduleId])
  @@index([roleId])
  @@index([moduleId])
  @@map("role_module_access")
}

enum TicketStatus {
  NEW
  OPEN
  PENDING
  ON_HOLD
  SOLVED
}

enum TicketPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum AssetKind {
  inline
  attachment
  derived
}

enum AssetVariant {
  original
  web
  thumb
}
