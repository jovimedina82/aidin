generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String               @id @default(uuid())
  email              String               @unique
  password           String?
  firstName          String
  lastName           String
  phone              String?
  userType           String               @default("Client")
  managerId          String?
  isActive           Boolean              @default(true)
  lastLoginAt        DateTime?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  azureId            String?              @unique
  userPrincipalName  String?              @unique
  jobTitle           String?
  officeLocation     String?
  mobilePhone        String?
  avatar             String?
  lastSyncAt         DateTime?
  classifierFeedback ClassifierFeedback[]
  createdKBArticles  KnowledgeBase[]      @relation("KBCreator")
  comments           TicketComment[]
  assignedTickets    Ticket[]             @relation("TicketAssignee")
  createdTickets     Ticket[]             @relation("TicketRequester")
  departments        UserDepartment[]
  alternateEmails    UserEmail[]
  preferences        UserPreference?
  roles              UserRole[]
  moduleAccess       UserModuleAccess[]
  attachments        Attachment[]         @relation("AttachmentUploader")
  manager            User?                @relation("UserManager", fields: [managerId], references: [id])
  directReports      User[]               @relation("UserManager")
  staffPresence      StaffPresence[]

  @@map("users")
}

model UserEmail {
  id         String    @id @default(uuid())
  userId     String    @map("user_id")
  email      String    @unique
  emailType  String    @default("alternate") @map("email_type")
  isPrimary  Boolean   @default(false) @map("is_primary")
  isVerified Boolean   @default(false) @map("is_verified")
  addedAt    DateTime  @default(now()) @map("added_at")
  addedBy    String?   @map("added_by")
  verifiedAt DateTime? @map("verified_at")
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([email])
  @@map("user_emails")
}

model Role {
  id           String             @id @default(uuid())
  name         String             @unique
  description  String?
  permissions  Json
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  users        UserRole[]
  moduleAccess RoleModuleAccess[]

  @@map("roles")
}

model UserRole {
  id     String @id @default(uuid())
  userId String
  roleId String
  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
  @@map("user_roles")
}

model Ticket {
  id                   String           @id @default(uuid())
  ticketNumber         String           @unique
  title                String
  description          String
  status               TicketStatus     @default(NEW)
  priority             TicketPriority   @default(NORMAL)
  category             String?
  requesterId          String?
  assigneeId           String?
  departmentId         String?
  emailConversationId  String?
  parentTicketId       String?
  aiDraftResponse      String?
  aiDraftGeneratedAt   DateTime?
  aiDraftGeneratedBy   String?
  satisfactionRating   Int?
  satisfactionFeedback String?
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  resolvedAt           DateTime?
  closedAt             DateTime?
  aiDecision           AIDecision?
  attachments          Attachment[]
  inboundMessages      InboundMessage[]
  messageAssets        MessageAsset[]   @relation("TicketAssets")
  comments             TicketComment[]
  kbUsage              TicketKBUsage[]
  ticketMessages       TicketMessage[]
  tags                 TicketTag[]
  cc                   TicketCC[]
  assignee             User?            @relation("TicketAssignee", fields: [assigneeId], references: [id])
  parentTicket         Ticket?          @relation("TicketThread", fields: [parentTicketId], references: [id])
  childTickets         Ticket[]         @relation("TicketThread")
  requester            User?            @relation("TicketRequester", fields: [requesterId], references: [id])

  // Performance indexes for common query patterns
  @@index([status])
  @@index([assigneeId])
  @@index([requesterId])
  @@index([departmentId])
  @@index([createdAt])
  @@index([updatedAt])
  @@index([resolvedAt])
  @@index([parentTicketId])
  // Composite indexes for complex queries
  @@index([status, assigneeId])
  @@index([status, requesterId])
  @@index([status, departmentId])
  @@index([status, updatedAt])
  @@index([priority, createdAt])
  @@index([emailConversationId])
  @@map("tickets")
}

model TicketComment {
  id          String       @id @default(uuid())
  ticketId    String
  userId      String
  content     String
  isPublic    Boolean      @default(true)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  ticket      Ticket       @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user        User         @relation(fields: [userId], references: [id])
  attachments Attachment[]

  @@index([ticketId, createdAt])
  @@index([userId])
  @@map("ticket_comments")
}

model WeeklyTicketStats {
  id                String   @id @default(uuid())
  weekStartDate     DateTime
  weekEndDate       DateTime
  year              Int
  weekNumber        Int
  totalTickets      Int      @default(0)
  newTickets        Int      @default(0)
  openTickets       Int      @default(0)
  pendingTickets    Int      @default(0)
  onHoldTickets     Int      @default(0)
  solvedTickets     Int      @default(0)
  closedTickets     Int      @default(0)
  unassignedTickets Int      @default(0)
  effectiveness     Float    @default(0)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([year, weekNumber])
  @@map("weekly_ticket_stats")
}

model UserPreference {
  id                 String   @id @default(uuid())
  userId             String   @unique
  personalViewOrder  String?
  companyViewOrder   String?
  dashboardCardOrder String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_preferences")
}

model Department {
  id            String              @id @default(uuid())
  name          String              @unique
  description   String?
  color         String              @default("gray")
  isActive      Boolean             @default(true)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  keywords      DepartmentKeyword[]
  knowledgeBase KnowledgeBase[]
  users         UserDepartment[]

  @@map("departments")
}

model UserDepartment {
  id           String     @id @default(uuid())
  userId       String
  departmentId String
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, departmentId])
  @@index([userId])
  @@index([departmentId])
  @@map("user_departments")
}

model DepartmentKeyword {
  id           String     @id @default(uuid())
  departmentId String
  keyword      String
  weight       Float      @default(1.0)
  isActive     Boolean    @default(true)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  @@unique([departmentId, keyword])
  @@map("department_keywords")
}

model KnowledgeBase {
  id              String          @id @default(uuid())
  title           String
  content         String
  tags            String?
  departmentId    String?
  createdById     String?
  isActive        Boolean         @default(true)
  embedding       String?
  images          String?
  usageCount      Int             @default(0)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  createdBy       User?           @relation("KBCreator", fields: [createdById], references: [id])
  department      Department?     @relation(fields: [departmentId], references: [id])
  ticketResponses TicketKBUsage[]

  @@map("knowledge_base")
}

model TicketKBUsage {
  id             String        @id @default(uuid())
  ticketId       String
  kbId           String
  relevance      Float         @default(0.0)
  usedInResponse Boolean       @default(false)
  createdAt      DateTime      @default(now())
  knowledgeBase  KnowledgeBase @relation(fields: [kbId], references: [id], onDelete: Cascade)
  ticket         Ticket        @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@unique([ticketId, kbId])
  @@map("ticket_kb_usage")
}

model AIDecision {
  id                   String   @id @default(uuid())
  ticketId             String   @unique
  suggestedDepartment  String?
  departmentConfidence Float?   @default(0.0)
  keywordMatches       String?
  aiReasoning          String?
  finalDepartment      String?
  wasOverridden        Boolean  @default(false)
  createdAt            DateTime @default(now())
  ticket               Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("ai_decisions")
}

model AuditLog {
  id               String   @id @default(uuid())
  ts               DateTime @default(now())
  action           String
  actorId          String?  @map("actor_id")
  actorEmail       String   @map("actor_email")
  actorType        String   @map("actor_type")
  impersonatedUser String?  @map("impersonated_user")
  entityType       String   @map("entity_type")
  entityId         String   @map("entity_id")
  targetId         String?  @map("target_id")
  requestId        String?  @map("request_id")
  correlationId    String?  @map("correlation_id")
  ip               String?
  userAgent        String?  @map("user_agent")
  prevValues       String?  @map("prev_values")
  newValues        String?  @map("new_values")
  metadata         String?
  redactionLevel   Int      @default(0) @map("redaction_level")
  prevHash         String?  @map("prev_hash")
  hash             String

  @@unique([action, entityId, requestId])
  @@index([ts(sort: Desc)])
  @@index([entityType, entityId, ts(sort: Desc)])
  @@index([action, ts(sort: Desc)])
  @@index([actorEmail, ts(sort: Desc)])
  @@index([requestId])
  @@index([correlationId])
  @@map("audit_log")
}

model AuditLogDLQ {
  id          String    @id @default(uuid())
  failedAt    DateTime  @default(now()) @map("failed_at")
  error       String
  retryCount  Int       @default(0) @map("retry_count")
  lastRetryAt DateTime? @map("last_retry_at")
  eventData   String    @map("event_data")
  resolved    Boolean   @default(false)
  resolvedAt  DateTime? @map("resolved_at")

  @@index([failedAt(sort: Desc)])
  @@index([resolved, failedAt(sort: Desc)])
  @@map("audit_log_dlq")
}

model AuditChainVerification {
  id              String    @id @default(uuid())
  verifiedAt      DateTime  @default(now()) @map("verified_at")
  rangeStart      DateTime  @map("range_start")
  rangeEnd        DateTime  @map("range_end")
  totalEntries    Int       @map("total_entries")
  verifiedEntries Int       @map("verified_entries")
  firstFailureId  String?   @map("first_failure_id")
  firstFailureTs  DateTime? @map("first_failure_ts")
  status          String
  details         String?

  @@index([verifiedAt(sort: Desc)])
  @@index([status, verifiedAt(sort: Desc)])
  @@map("audit_chain_verification")
}

model Attachment {
  id          String         @id @default(uuid())
  ticketId    String
  commentId   String?        @map("comment_id")
  userId      String
  fileName    String
  fileSize    Int
  mimeType    String
  filePath    String
  uploadedAt  DateTime       @default(now())
  expiresAt   DateTime
  sentInEmail Boolean        @default(false) // Track if attachment was already sent in an email
  ticket      Ticket         @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  comment     TicketComment? @relation(fields: [commentId], references: [id], onDelete: SetNull)
  user        User           @relation("AttachmentUploader", fields: [userId], references: [id])

  @@index([userId])
  @@index([ticketId])
  @@index([commentId])
  @@index([expiresAt])
  @@map("attachments")
}

model AttachmentDeletionLog {
  id        String   @id @default(uuid())
  userId    String
  fileName  String
  fileSize  Int
  filePath  String
  deletedAt DateTime @default(now())
  deletedBy String?
  reason    String

  @@index([userId])
  @@index([deletedAt])
  @@map("attachment_deletion_logs")
}

model ClassifierFeedback {
  id               String   @id @default(uuid())
  ticketId         String
  emailFrom        String?
  emailSubject     String?
  emailBody        String?
  originalCategory String?
  feedbackType     String
  correctCategory  String?
  reason           String?
  userId           String
  createdAt        DateTime @default(now())
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([ticketId])
  @@index([feedbackType])
  @@index([createdAt])
  @@map("classifier_feedback")
}

model EmailIngest {
  id              String            @id @default(uuid())
  messageId       String            @unique @map("message_id")
  inReplyTo       String?           @map("in_reply_to")
  references      String?
  conversationId  String?           @map("conversation_id")
  threadId        String?           @map("thread_id")
  from            String
  to              String
  cc              String?
  bcc             String?
  subject         String
  html            String?
  text            String?
  snippet         String?
  rawHeaders      String?           @map("raw_headers")
  parsedJson      String?           @map("parsed_json")
  dedupeHash      String            @map("dedupe_hash")
  receivedAt      DateTime          @default(now()) @map("received_at")
  processedAt     DateTime?         @map("processed_at")
  processingError String?           @map("processing_error")
  ticketId        String?           @map("ticket_id")
  attachments     EmailAttachment[]

  @@index([messageId])
  @@index([inReplyTo])
  @@index([conversationId])
  @@index([receivedAt(sort: Desc)])
  @@index([dedupeHash])
  @@index([from, receivedAt(sort: Desc)])
  @@map("email_ingest")
}

model EmailAttachment {
  id              String      @id @default(uuid())
  emailIngestId   String      @map("email_ingest_id")
  filename        String
  contentType     String      @map("content_type")
  size            Int
  storageKey      String?     @map("storage_key")
  storageUrl      String?     @map("storage_url")
  isInline        Boolean     @default(false) @map("is_inline")
  cid             String?
  uploadedAt      DateTime    @default(now()) @map("uploaded_at")
  virusScanStatus String?     @map("virus_scan_status")
  virusScanAt     DateTime?   @map("virus_scan_at")
  emailIngest     EmailIngest @relation(fields: [emailIngestId], references: [id], onDelete: Cascade)

  @@index([emailIngestId])
  @@index([cid])
  @@index([storageKey])
  @@map("email_attachments")
}

model TicketMessage {
  id          String    @id @default(uuid())
  ticketId    String    @map("ticket_id")
  kind        String
  authorId    String?   @map("author_id")
  authorEmail String?   @map("author_email")
  authorName  String?   @map("author_name")
  html        String?
  text        String?
  subject     String?
  metadata    String?
  isPublic    Boolean   @default(true) @map("is_public")
  createdAt   DateTime  @default(now()) @map("created_at")
  editedAt    DateTime? @map("edited_at")
  ticket      Ticket    @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([ticketId, createdAt])
  @@index([authorEmail])
  @@map("ticket_messages")
}

model DepartmentSequence {
  id             String   @id @default(uuid())
  departmentCode String   @unique @map("department_code")
  departmentName String   @map("department_name")
  nextNumber     Int      @default(1) @map("next_number")
  lastReservedAt DateTime @default(now()) @map("last_reserved_at")

  @@map("department_sequences")
}

model Tag {
  id          String      @id @default(uuid())
  name        String      @unique
  displayName String      @map("display_name")
  color       String?
  category    String?
  isActive    Boolean     @default(true) @map("is_active")
  usageCount  Int         @default(0) @map("usage_count")
  createdAt   DateTime    @default(now()) @map("created_at")
  tickets     TicketTag[]

  @@index([name])
  @@index([category])
  @@map("tags")
}

model TicketTag {
  id       String   @id @default(uuid())
  ticketId String   @map("ticket_id")
  tagId    String   @map("tag_id")
  addedAt  DateTime @default(now()) @map("added_at")
  addedBy  String?  @map("added_by")
  ticket   Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  tag      Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([ticketId, tagId])
  @@index([ticketId])
  @@index([tagId])
  @@map("ticket_tags")
}

model TicketCC {
  id        String   @id @default(uuid())
  ticketId  String   @map("ticket_id")
  email     String
  name      String?                                 // Optional display name
  addedAt   DateTime @default(now()) @map("added_at")
  addedBy   String?  @map("added_by")              // Who added this CC (user ID or "system" for auto-captured)
  source    String   @default("manual")             // "manual" (staff added) or "original" (from incoming email)
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@unique([ticketId, email])
  @@index([ticketId])
  @@index([email])
  @@map("ticket_cc")
}

model RateLimitEntry {
  id         String   @id @default(uuid())
  identifier String
  endpoint   String
  requestAt  DateTime @default(now()) @map("request_at")
  expiresAt  DateTime @map("expires_at")

  @@index([identifier, endpoint, requestAt(sort: Desc)])
  @@index([expiresAt])
  @@map("rate_limit_entries")
}

model EmailDLQ {
  id             String    @id @default(uuid())
  failedAt       DateTime  @default(now()) @map("failed_at")
  error          String
  stackTrace     String?   @map("stack_trace")
  retryCount     Int       @default(0) @map("retry_count")
  lastRetryAt    DateTime? @map("last_retry_at")
  messageId      String?   @map("message_id")
  from           String?
  subject        String?
  rawPayload     String    @map("raw_payload")
  resolved       Boolean   @default(false)
  resolvedAt     DateTime? @map("resolved_at")
  resolvedBy     String?   @map("resolved_by")
  resolutionNote String?   @map("resolution_note")

  @@index([failedAt(sort: Desc)])
  @@index([resolved, failedAt(sort: Desc)])
  @@index([messageId])
  @@map("email_dlq")
}

model InboundMessage {
  id            String         @id @default(uuid())
  ticketId      String         @map("ticket_id")
  messageId     String         @unique @map("message_id")
  from          String
  subject       String
  receivedAt    DateTime       @default(now()) @map("received_at")
  htmlRaw       String?        @map("html_raw")
  htmlSanitized String?        @map("html_sanitized")
  textPlain     String?        @map("text_plain")
  createdAt     DateTime       @default(now()) @map("created_at")
  ticket        Ticket         @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  assets        MessageAsset[]

  @@index([ticketId])
  @@index([messageId])
  @@index([receivedAt(sort: Desc)])
  @@map("inbound_messages")
}

model MessageAsset {
  id         String         @id @default(uuid())
  messageId  String         @map("message_id")
  ticketId   String         @map("ticket_id")
  kind       AssetKind
  contentId  String?        @map("content_id")
  filename   String
  mime       String
  size       Int
  sha256     String
  width      Int?
  height     Int?
  storageKey String         @map("storage_key")
  variant    AssetVariant
  createdAt  DateTime       @default(now()) @map("created_at")
  message    InboundMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  ticket     Ticket         @relation("TicketAssets", fields: [ticketId], references: [id], onDelete: Cascade)

  @@unique([messageId, contentId, variant])
  @@index([messageId])
  @@index([ticketId])
  @@index([sha256])
  @@index([contentId])
  @@map("message_assets")
}

model BlockedEmailDomain {
  id        String   @id @default(uuid())
  domain    String   @unique
  reason    String?
  blockedBy String
  blockedAt DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([domain])
  @@map("blocked_email_domains")
}

// System modules (features/sections of the application)
model Module {
  id          String   @id @default(uuid())
  name        String   @unique                     // Human-readable name (e.g., "Tickets", "Reports")
  key         String   @unique                     // Unique key (e.g., "tickets", "reports")
  description String?                              // Description of the module
  icon        String?                              // Icon name for UI (e.g., "Ticket", "BarChart3")
  route       String?                              // Primary route path (e.g., "/tickets", "/reports")
  category    String?                              // Module category (e.g., "core", "admin", "features")
  isCore      Boolean  @default(false) @map("is_core")      // Core modules can't be disabled (Dashboard, Profile)
  isActive    Boolean  @default(true) @map("is_active")   // Module is active and available
  sortOrder   Int      @default(0) @map("sort_order")     // Display order in UI
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  userModuleAccess UserModuleAccess[]
  roleModuleAccess RoleModuleAccess[]

  @@index([key])
  @@index([isActive])
  @@map("modules")
}

// Per-user module access (overrides role-based access)
model UserModuleAccess {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  moduleId  String   @map("module_id")
  hasAccess Boolean  @default(true) @map("has_access")  // Grant or deny access
  grantedBy String?  @map("granted_by")                 // Admin who granted/revoked access
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  module Module @relation(fields: [moduleId], references: [id], onDelete: Cascade)

  @@unique([userId, moduleId])
  @@index([userId])
  @@index([moduleId])
  @@map("user_module_access")
}

// Per-role module access (default access for users with this role)
model RoleModuleAccess {
  id        String   @id @default(uuid())
  roleId    String   @map("role_id")
  moduleId  String   @map("module_id")
  hasAccess Boolean  @default(true) @map("has_access")  // Grant or deny access
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)
  module Module @relation(fields: [moduleId], references: [id], onDelete: Cascade)

  @@unique([roleId, moduleId])
  @@index([roleId])
  @@index([moduleId])
  @@map("role_module_access")
}

enum TicketStatus {
  NEW
  OPEN
  PENDING
  ON_HOLD
  SOLVED
}

enum TicketPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum AssetKind {
  inline
  attachment
  derived
}

enum AssetVariant {
  original
  web
  thumb
}

// ==============================================
// PRESENCE MODULE - Data-driven, Extensible
// ==============================================

// Status lookup table - replaces hard-coded PresenceStatus enum
model PresenceStatusType {
  id             String          @id @default(uuid())
  code           String          @unique                    // e.g., "AVAILABLE", "VACATION", "REMOTE"
  label          String                                     // Display name: "Available", "Vacation"
  category       String          @default("presence")        // Category for grouping
  requiresOffice Boolean         @default(false)            // Whether this status requires an office location
  color          String?                                    // Hex color for UI (e.g., "#22c55e")
  icon           String?                                    // Icon name for UI (e.g., "Check", "Plane")
  isActive       Boolean         @default(true)             // Soft-disable instead of delete
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  staffPresence  StaffPresence[]

  @@index([isActive])
  @@index([code])
  @@map("presence_status_types")
}

// Office location lookup table - replaces hard-coded OfficeLocation enum
model PresenceOfficeLocation {
  id            String          @id @default(uuid())
  code          String          @unique                    // e.g., "NEWPORT_BEACH", "LAGUNA_BEACH"
  name          String                                     // Display name: "Newport Beach"
  isActive      Boolean         @default(true)             // Soft-disable instead of delete
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  staffPresence StaffPresence[]

  @@index([isActive])
  @@index([code])
  @@map("presence_office_locations")
}

// Staff presence - multi-segment daily schedules with 8h cap
model StaffPresence {
  id               String                    @id @default(uuid())
  userId           String                    @map("user_id")
  statusId         String                    @map("status_id")
  officeLocationId String?                   @map("office_location_id")
  notes            String?                                         // Max 500 chars, validated in app
  startAt          DateTime                  @map("start_at")      // UTC timestamp
  endAt            DateTime                  @map("end_at")        // UTC timestamp
  createdAt        DateTime                  @default(now())
  updatedAt        DateTime                  @updatedAt
  user             User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  status           PresenceStatusType        @relation(fields: [statusId], references: [id], onDelete: Restrict)
  officeLocation   PresenceOfficeLocation?   @relation(fields: [officeLocationId], references: [id], onDelete: Restrict)

  @@unique([userId, startAt, endAt, statusId, officeLocationId])
  @@index([userId, startAt])
  @@index([statusId])
  @@index([officeLocationId])
  @@map("staff_presence")
}

// AidIN Chat Sessions - AI assistant conversations for staff members
model AidinChatSession {
  id        String             @id @default(uuid())
  userId    String             @map("user_id")
  title     String             @default("New Chat")      // Auto-generated or user-set title
  createdAt DateTime           @default(now())           @map("created_at")
  updatedAt DateTime           @updatedAt                @map("updated_at")
  expiresAt DateTime                                     @map("expires_at") // Auto-delete after 30 days
  messages  AidinChatMessage[]

  @@index([userId, createdAt(sort: Desc)])
  @@index([expiresAt])
  @@map("aidin_chat_sessions")
}

// AidIN Chat Messages - Individual messages in chat sessions
model AidinChatMessage {
  id        String           @id @default(uuid())
  sessionId String           @map("session_id")
  role      String                                      // "user" or "assistant"
  content   String                                      // The message content
  createdAt DateTime         @default(now())            @map("created_at")
  session   AidinChatSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, createdAt])
  @@map("aidin_chat_messages")
}
