generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

model User {
  id              String          @id @default(uuid())
  email           String          @unique
  password        String?
  firstName       String
  lastName        String
  phone           String?
  userType        String          @default("Client")
  managerId       String?         // Reference to manager/supervisor
  isActive        Boolean         @default(true)
  lastLoginAt     DateTime?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  azureId         String?         @unique
  userPrincipalName String?       @unique
  jobTitle        String?
  officeLocation  String?
  mobilePhone     String?
  avatar          String?
  lastSyncAt      DateTime?
  comments        TicketComment[]
  assignedTickets Ticket[]        @relation("TicketAssignee")
  createdTickets  Ticket[]        @relation("TicketRequester")
  roles           UserRole[]
  preferences     UserPreference?
  departments     UserDepartment[]
  classifierFeedback ClassifierFeedback[]
  createdKBArticles KnowledgeBase[] @relation("KBCreator")

  // Hierarchical relationships
  manager         User?           @relation("UserManager", fields: [managerId], references: [id])
  directReports   User[]          @relation("UserManager")

  @@map("users")
}

model Role {
  id          String     @id @default(uuid())
  name        String     @unique
  description String?
  permissions Json
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  users       UserRole[]

  @@map("roles")
}

model UserRole {
  id     String @id @default(uuid())
  userId String
  roleId String
  role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, roleId])
  @@map("user_roles")
}

model Ticket {
  id                    String          @id @default(uuid())
  ticketNumber          String          @unique
  title                 String
  description           String
  status                TicketStatus    @default(NEW)
  priority              TicketPriority  @default(NORMAL)
  category              String?
  requesterId           String?
  assigneeId            String?
  departmentId          String?
  emailConversationId   String?         // Microsoft Graph conversationId for email threading
  parentTicketId        String?         // Parent ticket for threading
  aiDraftResponse       String?         // AI-generated draft response awaiting staff review
  aiDraftGeneratedAt    DateTime?       // When the AI draft was generated
  aiDraftGeneratedBy    String?         // User ID who triggered draft generation
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  resolvedAt            DateTime?
  closedAt              DateTime?
  comments              TicketComment[]
  assignee              User?           @relation("TicketAssignee", fields: [assigneeId], references: [id])
  requester             User?           @relation("TicketRequester", fields: [requesterId], references: [id])
  aiDecision            AIDecision?
  kbUsage               TicketKBUsage[]
  attachments           Attachment[]

  // Parent-child threading relationships
  parentTicket          Ticket?         @relation("TicketThread", fields: [parentTicketId], references: [id], onDelete: SetNull)
  childTickets          Ticket[]        @relation("TicketThread")

  @@index([parentTicketId])
  @@map("tickets")
}

model TicketComment {
  id        String   @id @default(uuid())
  ticketId  String
  userId    String
  content   String
  isPublic  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id])
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("ticket_comments")
}

enum TicketStatus {
  NEW
  OPEN
  PENDING
  ON_HOLD
  SOLVED
}

enum TicketPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

model WeeklyTicketStats {
  id                String   @id @default(uuid())
  weekStartDate     DateTime // Monday of the week
  weekEndDate       DateTime // Sunday of the week
  year              Int      // Year of the week
  weekNumber        Int      // Week number (1-53)
  totalTickets      Int      @default(0)
  newTickets        Int      @default(0)
  openTickets       Int      @default(0)
  pendingTickets    Int      @default(0)
  onHoldTickets     Int      @default(0)
  solvedTickets     Int      @default(0)
  closedTickets     Int      @default(0)
  unassignedTickets Int      @default(0)
  effectiveness     Float    @default(0) // percentage (solvedTickets / totalTickets * 100)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([year, weekNumber])
  @@map("weekly_ticket_stats")
}

model UserPreference {
  id                   String   @id @default(uuid())
  userId               String   @unique
  personalViewOrder    String?  // JSON array of view IDs
  companyViewOrder     String?  // JSON array of view IDs
  dashboardCardOrder   String?  // JSON array of card IDs for dashboard
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_preferences")
}

model Department {
  id          String             @id @default(uuid())
  name        String             @unique
  description String?
  color       String             @default("gray")
  isActive    Boolean            @default(true)
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  users       UserDepartment[]
  keywords    DepartmentKeyword[]
  knowledgeBase KnowledgeBase[]

  @@map("departments")
}

model UserDepartment {
  id           String     @id @default(uuid())
  userId       String
  departmentId String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  @@unique([userId, departmentId])
  @@map("user_departments")
}

model DepartmentKeyword {
  id           String     @id @default(uuid())
  departmentId String
  keyword      String
  weight       Float      @default(1.0)
  isActive     Boolean    @default(true)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  department   Department @relation(fields: [departmentId], references: [id], onDelete: Cascade)

  @@unique([departmentId, keyword])
  @@map("department_keywords")
}

model KnowledgeBase {
  id           String    @id @default(uuid())
  title        String
  content      String
  tags         String?   // JSON array of tags
  departmentId String?
  createdById  String?   // User who created the article
  isActive     Boolean   @default(true)
  embedding    String?   // JSON array of embeddings
  images       String?   // JSON array of image data
  usageCount   Int       @default(0)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  department   Department? @relation(fields: [departmentId], references: [id], onDelete: SetNull)
  createdBy    User?     @relation("KBCreator", fields: [createdById], references: [id], onDelete: SetNull)
  ticketResponses TicketKBUsage[]

  @@map("knowledge_base")
}

model TicketKBUsage {
  id          String        @id @default(uuid())
  ticketId    String
  kbId        String
  relevance   Float         @default(0.0)
  usedInResponse Boolean    @default(false)
  createdAt   DateTime      @default(now())
  ticket      Ticket        @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  knowledgeBase KnowledgeBase @relation(fields: [kbId], references: [id], onDelete: Cascade)

  @@unique([ticketId, kbId])
  @@map("ticket_kb_usage")
}

model AIDecision {
  id                String    @id @default(uuid())
  ticketId          String    @unique
  suggestedDepartment String?
  departmentConfidence Float? @default(0.0)
  keywordMatches    String?   // JSON array of matched keywords
  aiReasoning       String?
  finalDepartment   String?
  wasOverridden     Boolean   @default(false)
  createdAt         DateTime  @default(now())
  ticket            Ticket    @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("ai_decisions")
}

// Production-grade audit log with hash chain integrity
model AuditLog {
  id                String   @id @default(uuid())
  ts                DateTime @default(now())
  action            String
  actorId           String?  @map("actor_id")
  actorEmail        String   @map("actor_email")
  actorType         String   @map("actor_type") // human, system, service
  impersonatedUser  String?  @map("impersonated_user")
  entityType        String   @map("entity_type")
  entityId          String   @map("entity_id")
  targetId          String?  @map("target_id")
  requestId         String?  @map("request_id")
  correlationId     String?  @map("correlation_id")
  ip                String?
  userAgent         String?  @map("user_agent")
  prevValues        String?  @map("prev_values") // JSON
  newValues         String?  @map("new_values")  // JSON
  metadata          String?  // JSON
  redactionLevel    Int      @default(0) @map("redaction_level")
  prevHash          String?  @map("prev_hash")
  hash              String

  @@index([ts(sort: Desc)])
  @@index([entityType, entityId, ts(sort: Desc)])
  @@index([action, ts(sort: Desc)])
  @@index([actorEmail, ts(sort: Desc)])
  @@index([requestId])
  @@index([correlationId])
  @@unique([action, entityId, requestId])
  @@map("audit_log")
}

model AuditLogDLQ {
  id           String    @id @default(uuid())
  failedAt     DateTime  @default(now()) @map("failed_at")
  error        String
  retryCount   Int       @default(0) @map("retry_count")
  lastRetryAt  DateTime? @map("last_retry_at")
  eventData    String    @map("event_data") // JSON
  resolved     Boolean   @default(false)
  resolvedAt   DateTime? @map("resolved_at")

  @@index([failedAt(sort: Desc)])
  @@index([resolved, failedAt(sort: Desc)])
  @@map("audit_log_dlq")
}

model AuditChainVerification {
  id               String    @id @default(uuid())
  verifiedAt       DateTime  @default(now()) @map("verified_at")
  rangeStart       DateTime  @map("range_start")
  rangeEnd         DateTime  @map("range_end")
  totalEntries     Int       @map("total_entries")
  verifiedEntries  Int       @map("verified_entries")
  firstFailureId   String?   @map("first_failure_id")
  firstFailureTs   DateTime? @map("first_failure_ts")
  status           String    // valid, invalid, partial
  details          String?   // JSON

  @@index([verifiedAt(sort: Desc)])
  @@index([status, verifiedAt(sort: Desc)])
  @@map("audit_chain_verification")
}

model Attachment {
  id           String   @id @default(uuid())
  ticketId     String
  userId       String   // User who uploaded the file
  fileName     String   // Original file name
  fileSize     Int      // File size in bytes
  mimeType     String   // MIME type (image/png, application/pdf, etc.)
  filePath     String   // Relative path to the file on disk
  uploadedAt   DateTime @default(now())
  expiresAt    DateTime // Auto-calculated: uploadedAt + 6 months
  ticket       Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([ticketId])
  @@index([expiresAt])
  @@map("attachments")
}

model AttachmentDeletionLog {
  id           String   @id @default(uuid())
  userId       String   // User whose folder the file was in
  fileName     String
  fileSize     Int
  filePath     String
  deletedAt    DateTime @default(now())
  deletedBy    String?  // 'system' for auto-cleanup, userId for manual deletion
  reason       String   // 'expired', 'manual', 'ticket_deleted'

  @@index([userId])
  @@index([deletedAt])
  @@map("attachment_deletion_logs")
}

model ClassifierFeedback {
  id               String   @id @default(uuid())
  ticketId         String
  emailFrom        String?
  emailSubject     String?
  emailBody        String?
  originalCategory String?
  feedbackType     String   // 'NOT_TICKET', 'WRONG_CATEGORY', 'CORRECT'
  correctCategory  String?
  reason           String?
  userId           String
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt        DateTime @default(now())

  @@index([ticketId])
  @@index([feedbackType])
  @@index([createdAt])
  @@map("classifier_feedback")
}